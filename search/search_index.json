{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"All Workshops","text":"<p>All Workshops</p>"},{"location":"intro16S/01_metabarcoding-intro/","title":"Introduction","text":""},{"location":"intro16S/01_metabarcoding-intro/#intro-to-16s-metabarcoding","title":"Intro To 16S Metabarcoding","text":"<p>Acknowledgement</p> <p>This workshop was ported over from our previous repository located here</p>"},{"location":"intro16S/01_metabarcoding-intro/#best-contributors","title":"BEST Contributors","text":"<p>The bioinformatics workshop materials presented here are brought to you by the following groups at Tufts University:</p> <ul> <li>Research Technology - Tufts Technology Services</li> <li>Data Intensive Study Center (DISC)</li> <li>Clinical and Translational Science Institute (CTSI)</li> </ul>"},{"location":"intro16S/01_metabarcoding-intro/#contact","title":"Contact","text":"<p>To sign up for the BEST e-list use this link best@elist.tufts.edu to find out about Bioinformatics Education and Services at Tufts</p>"},{"location":"intro16S/02_background/","title":"Introduction to the Microbiome","text":"<ul> <li>The microbiome refers to the collective set of genes belonging to the microbiota in a specimen. The term microbiota represents the community of microbes themselves.</li> <li>Disturbances in the microbiome have been linked to multiple chronic conditions, including obesity, inflammatory bowel disease, alcoholic and nonalcoholic fatty liver disease, and hepatocellular carcinoma.</li> </ul>"},{"location":"intro16S/02_background/#microbiome-variability","title":"Microbiome Variability","text":"<ul> <li>Assessing a microbiome disturbance is not a trivial task as it is highly variable from person to person.</li> <li>Large sample sizes, hundreds of patients, are needed to overcome interindividual variability.</li> </ul>"},{"location":"intro16S/02_background/#sample-collection","title":"Sample Collection","text":"<ul> <li>Sample collection is also a difficult challenge and highly dependent on the study question.</li> <li>The microbiome can change in an individual over time, especially in diseases marked by flare ups like IBD.</li> <li>Samples might not be representative of the site in question. For example, a stool sample sits in the rectum \u2013 an environment that is undergoing dehydration and fermentation which might select for different bacteria than in the small intestine.</li> </ul>"},{"location":"intro16S/02_background/#confounding-factors","title":"Confounding Factors","text":"<ul> <li>When conducting a clinical experiment, it is pertinent to stratify accounting for age, gender, diet, etc.</li> <li>Sampling over time is incredibly valuable as you can better capture intrapatient variability.</li> <li>Additionally, the way the sample is processed can also confound your results</li> </ul>"},{"location":"intro16S/02_background/#what-is-an-amplicon","title":"What is an Amplicon?","text":"<ul> <li>Microbiome Amplicon sequencing involves sequencing a specific gene from microbial community</li> </ul>"},{"location":"intro16S/02_background/#why-sequence-one-gene","title":"Why Sequence One Gene?","text":"<ul> <li> <p>Genes can vary per organism and may not be well conserved across species. To assess the microbial community composition, we need to sequence a conserved gene across organisms of interest:</p> <ul> <li>16S ribosome DNA (rDNA) for prokaryotes</li> <li>18S rDNA and internal transcribed spacers (ITS) for eukaryotes </li> </ul> </li> <li> <p>In the selected gene there are different levels of conservation across organisms. To circumvent this parts of the gene with high conservation (like the V4 region of 16S rRNA) are selected for</p> </li> </ul> <p></p>"},{"location":"intro16S/02_background/#our-data","title":"Our Data","text":"<p>Today we will be analyzing the microbiome of wild type mice and the C57BL/6NTac laboratory mouse strain, from Rosshart et al. (2107), using amplicon data analysis:</p> <p></p>"},{"location":"intro16S/02_background/#amplicon-data-analysis","title":"Amplicon Data Analysis","text":"<p>The goal of amplicon data analysis is to generate amplicon sequence variant table (also called feature table).  Researchers can use this table to conduct further downstream analysis including:</p> <ul> <li>alpha/beta-diversity</li> <li>taxonomic composition</li> <li>difference comparison </li> <li>correlation anlysis</li> <li>network analysis</li> </ul> <p> </p> Modified from Liu et al. Protein &amp; Cell (2021) <p>Today we will be using the DADA2 method to perform our amplicon data analysis!</p> Other 16S Analysis Methods <ul> <li>USEARCH</li> <li>Mothur</li> <li>QIIME</li> </ul>"},{"location":"intro16S/03_setup/","title":"Setup","text":"<p>Prerequisites</p> <ul> <li>Request an account on the Tufts HPC Cluster</li> <li>Connect to the VPN if off campus</li> </ul>"},{"location":"intro16S/03_setup/#navigate-to-the-cluster","title":"Navigate To The Cluster","text":"<p>Once you have an account and are connected to the VPN/Tufts Network, navigate to the OnDemand Website and log in with your tufts credentials. Once you are logged in you'll notice a few navigation options:</p> <p></p> <p>Click on <code>Interactive Apps &gt; RStudio Pax</code> and you will see a form to fill out to request compute resources to use RStudio on the Tufts HPC cluster. We will fill out the form with the following entries:</p> <ul> <li><code>Number of hours</code> : <code>3</code></li> <li><code>Number of cores</code> : <code>1</code></li> <li><code>Amount of memory</code> : <code>8GB</code></li> <li><code>R version</code> : <code>4.0.0</code></li> <li><code>Reservation for class, training, workshop</code> : <code>Bioinformatics Workshop</code>---&gt; NOTE: This reservation closed on Nov 9, 2022, use Default if running through the materials after that date.</li> <li><code>Load Supporting Modules</code>: <code>boost/1.63.0-python3 java/1.8.0_60 gsl/2.6</code></li> </ul> <p>Click <code>Lauch</code> and wait until your session is ready. Click <code>Connect To RStudio Server</code>, and you will notice a new window will pop up with RStudio. </p>"},{"location":"intro16S/03_setup/#project-setup","title":"Project Setup","text":"<p>We are going to create a new project to begin:</p> <ol> <li>Go to <code>File</code> &gt; <code>New Project</code></li> <li><code>New Directory</code></li> <li><code>New Project</code></li> <li>Create a name for your project (e.g. <code>intro-to-16S</code>)</li> <li><code>Create Project</code></li> </ol>"},{"location":"intro16S/03_setup/#file-organization","title":"File Organization","text":"<p>In our project we will need some folders to contain our scripts, data and results:</p> <ul> <li>Click the New Folder icon</li> <li>Create a folder called data and click ok</li> <li>Following the same process, create a scripts folder and a results folder</li> </ul>"},{"location":"intro16S/03_setup/#data-scripts","title":"Data &amp; Scripts","text":"<p>Today we will be working with data from Rosshart et al. (2107) where wild-type and laboratory strain mouse microbiomes were assessed. To copy over  this data we will enter the following command into the console:</p> <pre><code>file.copy(from=\"/cluster/tufts/bio/tools/training/microbiome16S/raw_fastq/\",to=\"./data/\", recursive = TRUE)\nfile.copy(from=\"/cluster/tufts/bio/tools/training/microbiome16S/meta/metaData.txt\",to=\"./data/\", recursive = TRUE)\nfile.copy(from=\"/cluster/tufts/bio/tools/training/microbiome16S/silva/silva_nr99_v138.1_train_set.fa.gz\",to=\"./data/\")\nfile.copy(from=\"/cluster/tufts/bio/tools/training/microbiome16S/scripts/dada2pipeline.Rmd\",to=\"./scripts/\")\n</code></pre> <p>Now that we have our data and scripts copied, let's navigate to our scripts folder and open up \"dada2pipeline.Rmd\".</p>"},{"location":"intro16S/03_setup/#libraries","title":"Libraries","text":"<p>To run a code chunk in this R markdown file, click the play button at the top right hand side of the code chunk. We will practice by running the code chunk that loads the R libraries we will need for this workshop:</p> <pre><code># load our libraries\n.libPaths(c('/cluster/tufts/hpc/tools/R/4.0.0',.libPaths()))\nlibrary(dada2)\nlibrary(phyloseq)\nlibrary(ggplot2)\nlibrary(DESeq2)\nlibrary(tidyverse)\nlibrary(phangorn)\nlibrary(msa)\n</code></pre>"},{"location":"intro16S/04_quality-control/","title":"Quality Control","text":""},{"location":"intro16S/04_quality-control/#sequencing-overview","title":"Sequencing Overview","text":"<ul> <li>Marker gene (16S, 18S, or ITS) is selected</li> <li>Primers target areas of high conservation in gene </li> <li>DNA is fragmented </li> <li>Adapters are added to help the DNA attach to a flow cell</li> <li>Barcodes may also be added to identify which DNA came from which sample</li> <li>The fragments are sequenced to produce reads</li> <li>Reads can be single-end (one strand sequenced) or paired-end (both strands sequenced) </li> </ul>"},{"location":"intro16S/04_quality-control/#sequencing-read-data","title":"Sequencing Read Data","text":"<ul> <li>After sequencing we end up with a FASTQ file which contains:<ul> <li>A sequence label</li> <li>The nucleic acid sequence</li> <li>A separator</li> <li>The quality score for each base pair</li> </ul> </li> </ul>"},{"location":"intro16S/04_quality-control/#demultiplexing","title":"Demultiplexing","text":"<ul> <li>Sometimes samples are mixed to save on sequencing cost </li> <li>To identify which DNA is from which sample Barcodes are added</li> <li>Before moving forward samples need to separated and those DNA barcodes need to be removed </li> <li>Tools like sabre can demultiplex pooled FASTQ data</li> </ul>"},{"location":"intro16S/04_quality-control/#quality-scores","title":"Quality Scores","text":"<ul> <li>Quality Scores are the probability that a base was called in error</li> <li>Higher scores indicate that the base is less likely to be incorrect</li> <li>Lower scores indicate that the base is more likely to be incorrect</li> </ul>"},{"location":"intro16S/04_quality-control/#dada2-quality-control","title":"DADA2 Quality Control","text":"<p>Warning</p> <p>DADA2 assumes that your read data has had any adapters removed and that your data is demultiplexed!  Check out sabre to demultiplex your samples and Cutadapt to remove adapters</p> <p>We begin by specifying the path to our data, sorting by forward and reverse strands, and grabbing our sample names:</p> <pre><code># path to files\npath &lt;- \"../data/raw_fastq\"\n\n# sort our files by forward and reverse strands \n# so that the sample names for each strand matches\n# our data has the pattern \"_pass_1.fastq.gz\" \n# and \"_pass_2.fastq.gz\"\npath2Forward &lt;- sort(\nlist.files(\npath,\npattern=\"_pass_1.fastq.gz\",\nfull.names = TRUE)\n)\npath2Reverse &lt;- sort(\nlist.files(\npath,\npattern=\"_pass_2.fastq.gz\",\nfull.names = TRUE)\n)\n\n# now let's grab our sample names\nsampleNames &lt;- sapply(\nstrsplit(\nbasename(path2Forward), \"_\"), `[`, 1)\n</code></pre> <p>DADA2 has built in plotting features that allow you to inspect your fastq files:</p> <pre><code># plot the forward strand quality plot of our first two sample\ndada2::plotQualityProfile(path2Forward[1:2])+\nguides(scale = \"none\")\n</code></pre> <p></p> <pre><code># plot the reverse strand quality plot of our first two sample\ndada2::plotQualityProfile(path2Reverse[1:2])+\nguides(scale = \"none\")\n</code></pre> <p></p> <p>What does the graph tell us?</p> <ul> <li>Here we see that the quality scores drop off around the 200th base position for the forward reads and the 150th base position for the reverse reads</li> <li>The error rate is considered when determining true biological sequences but is more sensitive to rare biological senquences when reads are trimmed.</li> </ul> <p>Trimming Considerations</p> <ul> <li>The data we are using are 2x250 V4 sequence data. For data that do not overlap as much (i.e. data from the V1-V2 or V3-V4 regions), be wary that this may affect how the reads are merged later on. </li> </ul>"},{"location":"intro16S/04_quality-control/#trimming","title":"Trimming","text":"<p>Here we notice a dip in quality scores and will trim using the base DADA2 filters:</p> <pre><code># create new file names for filtered forward/reverse fastq files\n# name each file name in the vector with the sample name\n# this way we can compare the forward and reverse files \n# when we filter and trim\nfiltForward &lt;- file.path(path, \"filtered\", paste0(sampleNames, \"_F_filt.fastq.gz\"))\nfiltReverse &lt;- file.path(path, \"filtered\", paste0(sampleNames, \"_R_filt.fastq.gz\"))\nnames(filtForward) &lt;- sampleNames\nnames(filtReverse) &lt;- sampleNames\n\n# Now we will filter and trim our sequences\nout &lt;- filterAndTrim(\npath2Forward,\nfiltForward,\npath2Reverse, filtReverse,\ntruncLen = c(200,150),\nmaxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE,\ncompress=TRUE)\n</code></pre> <p>What do these options mean?</p> <ul> <li><code>truncLen</code>: truncate reads after this base <ul> <li>Here we truncate after base 200 for the forward reads and after basae 150 for the reverse reads</li> </ul> </li> <li><code>maxN</code>: After truncation, sequences with more than maxN Ns will be discarded. Note that dada does not allow Ns.</li> <li><code>maxEE</code>: After truncation, reads with higher than maxEE \"expected errors\" will be discarded.</li> <li><code>truncQ</code>: Truncate reads at the first instance of a quality score less than or equal to <code>truncQ</code></li> <li><code>rm.phix</code>: If TRUE, discard reads that match against the phiX genome<ul> <li>Illumina control libraries derived from a PhiX genome, are used to reduce ambiguity in base calls when highly repetitive sequences are generated. It is pertinent to remove reads mapping to the PhiX genome to ensure you are assessing your microbial community and not the Illumina control run.</li> </ul> </li> <li><code>compress</code>:  If TRUE, the output fastq file(s) are gzipped</li> </ul>"},{"location":"intro16S/05_error-asv/","title":"Error Models & Sequence Variants","text":""},{"location":"intro16S/05_error-asv/#dada2-error-model","title":"DADA2 Error Model","text":"<ul> <li>The DADA2 error model attempts to assess whether a sequence is too abundant to be explained by errors in amplicon sequencing. </li> </ul> <p>Here we will leverage this model to learn error rates and then plot them:</p> <pre><code># Learn Error Rates\n\n# dada2 uses a parametric model to learn the error rates\n# for each sequence\nerrForward &lt;- learnErrors(filtForward)\nerrReverse &lt;- learnErrors(filtReverse)\n\n# plot the error rate against theoretical error rates\nplotErrors(errForward,nominalQ=TRUE)\n</code></pre> <p></p> <p>Info</p> <p>So the red line indicates our expected error rate. Essentially, as the quality score gets better so does our error rate.  The black points/line our are actual error rates and we are looking for the trend of the black line to match the trend of the red line.  Here we expect a little deviation since our sample has been subsampled.</p>"},{"location":"intro16S/05_error-asv/#inferring-sequence-variants","title":"Inferring Sequence Variants","text":"<ul> <li>So far, we have assigned p-values for each sequence in each sample</li> <li>DADA2 then tries to determine which sequences are of biological origin and which aren\u2019t by assessing which sequences are present in other samples</li> <li>If a sequence is present in another sample, it is more likely that it is a real biological sequence</li> </ul> <pre><code># Infer Sequnce Variants\n\n# we will now run the dada2 algorithm \n# this algorithm delivers \"true\" sequence variants\n# with information gathered from the error model \n# generated above\ndadaForward &lt;- dada(filtForward, err=errForward)\ndadaReverse &lt;- dada(filtReverse, err=errReverse)\n\n# let's get a summary of our first sample\ndadaForward[[1]]\n</code></pre> <pre><code>dada-class: object describing DADA2 denoising results\n35 sequence variants were inferred from 430 input unique sequences.\nKey parameters: OMEGA_A = 1e-40, OMEGA_C = 1e-40, BAND_SIZE = 16\n</code></pre> <p>Info</p> <p>Here we note that even though we have 430 unique sequences in our data, only 35 of them have been deemed true sequence variants.</p>"},{"location":"intro16S/06_merging-chimeras-taxonomy/","title":"Merging Chimeras & Taxonomy","text":""},{"location":"intro16S/06_merging-chimeras-taxonomy/#merging-reads","title":"Merging Reads","text":"<ul> <li>For paired-end data there is a good deal of overlap between the forward and reverse read</li> <li>To resolve this redundancy, these reads are collapsed into contigs</li> </ul> <p>Let's do this with code now!</p> <pre><code># Merge Read Pairs\n\n# so far we have \"denoised\", so to speak, \n# these sequence variants. We now need to merge the\n# forward and reverse strands\nmergers &lt;- mergePairs(\ndadaForward,\nfiltForward,\ndadaReverse, filtReverse, verbose=TRUE)\n</code></pre> <pre><code>619 paired-reads (in 18 unique pairings) successfully merged out of 807 (in 82 pairings) input.\n570 paired-reads (in 29 unique pairings) successfully merged out of 815 (in 136 pairings) input.\n619 paired-reads (in 28 unique pairings) successfully merged out of 868 (in 128 pairings) input.\n713 paired-reads (in 18 unique pairings) successfully merged out of 860 (in 76 pairings) input.\n609 paired-reads (in 29 unique pairings) successfully merged out of 851 (in 133 pairings) input.\n620 paired-reads (in 30 unique pairings) successfully merged out of 810 (in 115 pairings) input.\n679 paired-reads (in 28 unique pairings) successfully merged out of 845 (in 104 pairings) input.\n616 paired-reads (in 28 unique pairings) successfully merged out of 830 (in 106 pairings) input.\n</code></pre> <p>Info</p> <p>Here we see that for each sample we get the number of reads that were able to be successfully merged out of the total number of reads that could be merged.</p>"},{"location":"intro16S/06_merging-chimeras-taxonomy/#asvs-vs-otus","title":"ASVs vs. OTUs","text":"<ul> <li>Now that we have finally merged our sequence variants we are left with an Amplicon Sequence Variant. </li> <li>Traditional 16S metagenomic approaches use OTUs or operational taxonomic units instead of ASVs. </li> <li>Operational taxonomic units (OTUs): clusters of reads that differ by less than a fixed sequence dissimilarity threshold, most commonly 3%  Instead of clustering sequences, methods that resolve amplicon sequence variants (ASVs) distinguish sequence variants differing by as little as one nucleotide. ASVs represent a biological reality and provide nucleotide-level resolution. Callahan, MucMurdie, &amp; Holmes (2017) have demonstrated that \u201cASVs capture all biological variation present in the data, and ASVs inferred from a given data set can be reproduced in future data sets and validly compared between data sets.\u201d</li> </ul>"},{"location":"intro16S/06_merging-chimeras-taxonomy/#asv-table","title":"ASV Table","text":"<p>Now that our sequences are merged we can create an ASV counts table, basically telling us how which samples contain which ASV's:</p> <pre><code># Making a Sequence Table\n\n# now that we have merged sequences we can construct\n# an Amplicon Sequence Variant (ASV) table\nseqtab &lt;- makeSequenceTable(mergers)\n</code></pre>"},{"location":"intro16S/06_merging-chimeras-taxonomy/#chimera-removal","title":"Chimera Removal","text":"<ul> <li>During Sequencing microbial DNA is subjected to PCR to amplify DNA</li> <li>During PCR it is possible for two unrelated templates to form a non-biological hybrid sequence</li> <li>DADA2 finds these chimeras by:<ul> <li>aligning each sequence to more abundant sequences </li> <li>now check low abundant sequences and determine:<ul> <li>can this sequence be created if we mix the left and right sides of the abundant sequences</li> </ul> </li> </ul> </li> </ul> <p>Now in code:</p> <pre><code># Removing Chimeras\n\n# Chimeric sequences occur as errors during PCR \n# when two unrelated templates for a hybrid sequence\n# we will need to remove them before going forward\n\nseqtab.nochim &lt;- removeBimeraDenovo(seqtab, method=\"consensus\", verbose=TRUE)\n</code></pre> <p>Now let's check if any chimeric sequences are removed:</p> <pre><code>## check to see if the dimensions are different\n## between the chimera filtered and unfiltered\n## ASV tables\n\ndim(seqtab)\ndim(seqtab.nochim)\n</code></pre> <pre><code>[1]   8 119\n[1]   8 117\n</code></pre> <p>Info</p> <p>We can see here that 2 chimeric sequences were removed because our before and after sequence count matrices differ by two columns.</p>"},{"location":"intro16S/06_merging-chimeras-taxonomy/#pipeline-quality-control","title":"Pipeline Quality Control","text":"<p>We will also take a moment to do some final QC:</p> <pre><code># Final QC\n\n## we have performed quite a few steps \n## and it would be nice to get a final qc check \n## before assigning taxonomy\ngetN &lt;- function(x) sum(getUniques(x))\nfinalQC &lt;- cbind(\nout, sapply(dadaForward, getN),\nsapply(dadaReverse, getN),\nsapply(mergers, getN),\nrowSums(seqtab.nochim))\ncolnames(finalQC) &lt;- c(\"input\", \"filtered\", \"denoisedF\", \"denoisedR\", \"merged\", \"nonchim\")\nrownames(finalQC) &lt;- sampleNames\nfinalQC\n</code></pre> <pre><code>           input filtered denoisedF denoisedR merged nonchim\nSRR5690809  1000      905       840       855    619     611\nSRR5690810  1000      937       853       885    570     549\nSRR5690811  1000      937       880       910    619     594\nSRR5690812  1000      924       886       888    713     700\nSRR5690819  1000      938       872       906    609     609\nSRR5690820  1000      916       870       844    620     620\nSRR5690821  1000      921       883       879    679     679\nSRR5690822  1000      940       865       891    616     616\n</code></pre> <p>Info</p> <p>Here we see that we start with 1000 sequences per sample, end up with around 900 after filtering, around 800 after denoising to  find unique sequences, and around 600-700 sequences after merging sequences and removing chimeric sequences.</p>"},{"location":"intro16S/06_merging-chimeras-taxonomy/#assigning-taxonomy","title":"Assigning Taxonomy","text":"<ul> <li>To determine which taxon each  ASV belongs to DADA2 uses a na\u00efve bayes classifier </li> <li>This classifier uses a set of reference sequences with known taxonomy, here we use the SILVA database, as the training set and and outputs taxonomic assignments with bootstrapped confidence</li> </ul> <pre><code># Assigning Taxonomy\n\n# dada2 uses a naive Bayes classifier when\n# assigning taxonomy. This means we need a training\n# set of sequences with known taxonomy information.\n# here we use the silva database\n\ntaxa &lt;- assignTaxonomy(seqtab.nochim, \"../data/silva_nr99_v138.1_train_set.fa.gz\")\n</code></pre>"},{"location":"intro16S/06_merging-chimeras-taxonomy/#databases","title":"Databases","text":"<p>While we use the SILVA database here, there are other options databases:</p> <ul> <li>NCBI 16S RefSeq Database</li> <li>Greengenes</li> </ul> <p>Time for a break!</p>"},{"location":"intro16S/07_diversity-analysis/","title":"Diversity Analysis","text":""},{"location":"intro16S/07_diversity-analysis/#constructing-the-phylogenetic-tree","title":"Constructing the Phylogenetic Tree","text":"<p>We will now construct a phylogenic tree based on our sequence data. To construct our tree we will be first aligning our ASV's using ClustalW and then constructing a phylogenetic tree via the neighborhood joining method. </p> <p>To learn more about ClustalW and the neighborhood joining method visit:</p> <ul> <li>Clustal W and Clustal X version 2.0</li> <li>The neighbor-joining method: a new method for reconstructing phylogenetic trees.</li> </ul> <p>Let's work this in R!</p> <pre><code># extract sequences\n# name the sequences with their sequence so \n# that the ends of the phylogenetic tree are labeled\n# align these sequences\nseqs &lt;- getSequences(seqtab)\nnames(seqs) &lt;- seqs mult &lt;- msa(seqs, method=\"ClustalW\", type=\"dna\", order=\"input\")\n\n# convert multiple sequence alignment to a phyDat object\n# calculate the nucleotide distances between ASVs\n# use a neighbor joining algorithm to generate the tree\n# finally calculate the likelihood of the tree given the sequence alignment\nphang.align &lt;- as.phyDat(mult, type=\"DNA\", names=getSequence(seqtab))\ndm &lt;- dist.ml(phang.align)\ntreeNJ &lt;- NJ(dm)\nfit = pml(treeNJ, data=phang.align)\n</code></pre>"},{"location":"intro16S/07_diversity-analysis/#making-a-phyloseq-object","title":"Making a PhyloSeq Object","text":"<p>Once we have quantified our community, we can analyze its composition. Two main methods of doing so are exploring the alpha and beta diversity of the community. First we will need to take our taxonomic data and pass it to the <code>phyloseq</code> package for easier manipulation:</p> <pre><code># Create phyloseq object\n\n# upload meta data for study\n# ensure the rownames of our meta data are our sample name\nmeta &lt;- read.csv(\"../data/metaData.txt\")\nrownames(meta) &lt;- meta$Run\n\n# combine the ASV table, the meta data, and taxonomic data\n# to create the phyloseq object\nps &lt;- phyloseq(otu_table(seqtab.nochim, taxa_are_rows=FALSE), sample_data(meta), tax_table(taxa),\nphy_tree(fit$tree)\n)\n\n# Update ASV names to be shorter\n\n# The full ASV DNA sequence can be hard to look at\n# for this reason we move the sequence information to \n# the refseq slot of the phyloseq object\ndna &lt;- Biostrings::DNAStringSet(taxa_names(ps))\nnames(dna) &lt;- taxa_names(ps)\nps &lt;- merge_phyloseq(ps, dna)\ntaxa_names(ps) &lt;- paste0(\"ASV\", seq(ntaxa(ps)))\n</code></pre>"},{"location":"intro16S/07_diversity-analysis/#to-rarefy-or-not-to-rarefy","title":"To Rarefy Or Not To Rarefy?","text":"<ul> <li>Rarefaction curves are used to estimate the fraction of species that have been sequenced and usually result in a plot looking something like the following:</li> </ul> <p>What does this mean?</p> <ul> <li>Green curve: a plateau is present and it appears that most species have been sequenced</li> <li>Blue curve: this appears to be a species rich environment and we have not hit our plateau yet</li> <li>Brown curve: only a small fraction of the species appear to have been sequenced as the curve is rapidly rising</li> </ul> <ul> <li>There has been recent debate about whether or not to rarefy amplicon sequencing data:<ul> <li>Pros: Weiss et al. 2017 have noted that sequencing depth has an effect on ordination space and how species richness is displayed </li> <li>Cons: McMurdie and Holmes 2014 have noted that this depends on the species richness metric. </li> </ul> </li> <li>In this tutorial we won't be applying rarefaction to our data.</li> </ul>"},{"location":"intro16S/07_diversity-analysis/#alpha-diversity","title":"Alpha Diversity","text":"<ul> <li> <p>Alpha Diversity: diversity of organisms sharing the same community or habitat. Alpha diversity metrics can look at richness, evenness, or both within a sample. </p> <ul> <li>Alpha Diversity Metrics:<ul> <li>Faith\u2019s PD: Phylogenetic diversity</li> <li>Observed OTUs: Richness of community</li> <li>Shannon: Balances richness and evenness</li> <li>Pielou\u2019s Evenness: Evenness of community</li> </ul> </li> </ul> </li> <li> <p>We will use the Shannon or Simpson Diversity indices to measure this complexity per sample.</p> </li> </ul> Optional: How to calculate these diversity metrics <p></p> <ul> <li> <p>Here we note:</p> <ul> <li>Shannon Diversity Index: higher values = higher diversity</li> <li>Simpson Diversity Index: higher values = higher diversity</li> </ul> </li> </ul> <p>In R we can visualize this with:</p> <pre><code># Plotting Alpha Diversity Metrics\nplot_richness(ps, x=\"Host\", measures=c(\"Shannon\", \"Simpson\"), color=\"Host\")+\ntheme_bw()+\ntheme(axis.text.x = element_text(angle=65,hjust=1))\n</code></pre> <p></p> <p>Note</p> <p>When running alpha and beta diversity plots you will notice some errors. This is due to the subsampling we needed to do on this data to ensure multiple users could run this workshop at the same time.</p>"},{"location":"intro16S/07_diversity-analysis/#beta-diversity","title":"Beta Diversity","text":"<ul> <li> <p>Beta Diversity: diversity between communities. Beta diversity calculates how similar two total ecosystems are.</p> <ul> <li>Beta Diversity<ul> <li>Unweighted Unifrac: Presence / absence phylogenetic distance between samples</li> <li>Weighted Unifrac: Abundance weighted phylogenetic distance between samples</li> <li>Jaccard: Presence / absence distance between samples</li> <li>Bray Curtis: Abundance weighted distance between samples</li> </ul> </li> </ul> </li> <li> <p>Here we will use the weighted UniFrac distance since it aware of phylogenetic distances</p> </li> </ul> Optional: How to calculate UniFrac Distance <p></p> <ul> <li>\\(N\\) is the number of nodes in the tree</li> <li>\\(S\\) is the number of sequences represented by the tree</li> <li>\\(L_i\\) is the branch length between node \\(i\\) and its parent </li> <li>\\(L_j\\) is the total branch length from the root to the tip of the tree for sequence \\(j\\)</li> <li>\\(A_i\\) and \\(B_i\\) are the number of sequences from communities \\(A\\) and \\(B\\) that descend from the node, </li> <li>\\(A_T\\) and \\(B_T\\) are the total number of sequences from communities \\(A\\) and \\(B\\).</li> </ul> <p>Mothur UniFrac Alogrith</p> <p>We can plot this in R code:</p> <pre><code># calculate the unifrac distance between samples \n# plot unifrac distances\nordu = ordinate(ps, \"PCoA\", \"unifrac\", weighted=TRUE)\nplot_ordination(ps, ordu, color=\"Host\")+\ntheme_bw()+\nlabs(title = \"Unifrac Distances\")\n</code></pre> <p></p> <p>Here we note that the wild type and C57BL/6NTac cluster together.</p> Which mouse line do you expect to be more spread on the Bray-Curtis Distance plot? <ul> <li>Laboratory Mouse Line (C57BL/6NTac)</li> <li>Wild Type (Mus musculus domesticus)</li> </ul>"},{"location":"intro16S/08_differential-abundance/","title":"Differential Abundance","text":"<p>When assessing a microbial community, you might be interested to determine which taxa are differentially abundant between conditions. Given that we have a counts matrix we can use DESeq2!</p>"},{"location":"intro16S/08_differential-abundance/#phylum-present","title":"Phylum Present","text":"<p>Before we assess which phylum are differentially abundant, a bar plot can be a quick first pass at determining this:</p> <pre><code># transform the sample counts to proportions\n# separate out our proportions\n# separate our our tax info\nps.prop &lt;- transform_sample_counts(ps, function(OTU) OTU/sum(OTU))\notu = data.frame(t(data.frame(ps.prop@otu_table)))\ntax = data.frame(ps.prop@tax_table) # merge the otu table and phylum column\n# reshape our data to be accepted by ggplot\n# merge taxa data with sample meta data\nmerged &lt;- merge(otu,\ntax %&gt;% select(Phylum),\nby=\"row.names\") %&gt;%\nselect(-Row.names) %&gt;%\nreshape2::melt() %&gt;%\nmerge(.,\ndata.frame(ps.prop@sam_data) %&gt;%\nselect(Run,Host),\nby.x=\"variable\",\nby.y=\"Run\")\n\n# plot our taxa \ntaxa_plot &lt;- ggplot(merged,aes(x=variable,y=value,fill=Phylum)) +\ngeom_bar(stat='identity') +\ntheme_bw()+\ntheme(axis.text.x = element_text(angle=45,hjust=1))+\nlabs(\nx=\"\",\ny=\"Abundance\",\ntitle = \"Barplot of Phylum Abundance\"\n)+\nfacet_wrap(Host ~ ., scales = \"free_x\")\ntaxa_plot\n</code></pre> <p></p> <p>Here we note that the wild type seem to have an abundance of Campylobacteria and the C57BL/6NTac have an abundance of Bacteriodota. Let's see if our DESeq2 results confirm this.</p>"},{"location":"intro16S/08_differential-abundance/#differential-abundance","title":"Differential Abundance","text":"<p>Differential Abundance measures which taxa are differentially abundant between conditions. So how does it work:</p>"},{"location":"intro16S/08_differential-abundance/#deseq2-normalization","title":"DESeq2 Normalization:","text":"<ol> <li>Geometric mean per ASV</li> <li>Divide rows by geometric mean</li> <li>Take the median of each sample</li> <li>Divide all ASV counts by that median</li> </ol>"},{"location":"intro16S/08_differential-abundance/#deseq2-model","title":"DESeq2 Model","text":"<ol> <li>The normalized abundances of an ASV are plotted against two conditions</li> <li>The regression line that connects these data is used to determine the p-value for differential abundance</li> </ol>"},{"location":"intro16S/08_differential-abundance/#deseq2-p-value","title":"DESeq2 P-Value","text":"<ol> <li>The Slope or \ud835\udefd1 is used to calculate a Wald Test Statistic \ud835\udc4d</li> <li>This statistic is compared to a normal distribution to determine the probability of getting that statistic </li> </ol> <p>Now how do we do this in R?</p> <pre><code># Differential Abundance\n\n## convert phyloseq object to DESeq object this dataset was downsampled and \n## as such contains zeros for each ASV, we will need to\n## add a pseudocount of 1 to continue and ensure the data are still integers\n## run DESeq2 against Host status, and ensure wild type is control,\n## filter for significant changes and add in phylogenetic info\ndds = phyloseq_to_deseq2(ps, ~ Host)\ndds@assays@data@listData$counts = apply((dds@assays@data@listData$counts +1),2,as.integer)\ndds = DESeq(dds, test=\"Wald\", fitType=\"parametric\")\nres = data.frame(\nresults(dds,\ncooksCutoff = FALSE, contrast = c(\"Host\",\"C57BL/6NTac\",\"Mus musculus domesticus\")))\nsigtab = res %&gt;%\ncbind(tax_table(ps)[rownames(res), ]) %&gt;%\ndplyr::filter(padj &lt; 0.05) ## order sigtab in direction of fold change\nsigtab &lt;- sigtab %&gt;%\nmutate(Phylum = factor(as.character(Phylum), levels=names(sort(tapply(\nsigtab$log2FoldChange, sigtab$Phylum, function(x) max(x)))))\n)\n\n# as a reminder let's plot our abundance data again\ntaxa_plot\n\n## plot differential abundance\nggplot(sigtab , aes(x=Phylum, y=log2FoldChange, color=padj)) + geom_point(size=6) + theme_bw() +\ntheme(axis.text.x = element_text(angle = 60, hjust = 1)) +\nggtitle(\"Mus musculus domesticus v. C57BL/6NTac\")\n</code></pre> <p></p> <p></p> <p>Explanation of Results</p> <ul> <li>Wild type seem to have an abundance of Campylobacteria and the C57BL/6NTac have an abundance of Bacteriodota</li> <li>Proteobacteria are severely downregulated in our C57BL/6NTac mice. However, they only show up in one sample!</li> <li>Be sure that your data are not influenced by outliers!</li> <li>Additionally, we collapsed our ASV's to the Phylum level since all ASV's had an identified phylum</li> </ul> Optional: How do I turn this R markdown into an R script? <ul> <li>run the following code (being sure to change the path to where your script is): </li> <li><code>knitr::purl(\"dada2pipeline.Rmd\")</code></li> <li>You should now find an R script called <code>dada2pipeline.R</code>!</li> </ul> <p>References</p> <ol> <li>Galaxy Project - Metagenomics</li> <li>Microbiome 101</li> <li>Current understanding of the human microbiome</li> <li>Amplicon and metagenomics overview</li> <li>Variable regions of the 16S ribosomal RNA</li> <li>A primer on microbial bioinformatics for nonbioinformaticians</li> <li>usearch</li> <li>Sample Multiplexing Overview</li> <li>DADA2: High resolution sample inference from Illumina amplicon data</li> <li>Chimeric 16S rRNA sequence formation and detection in Sanger and 454-pyrosequenced PCR amplicons</li> <li>DADA2 Pipeline Tutorial (1.16)</li> <li>Statistics How To</li> <li>Hierarchical Clustering in Data Mining</li> <li>Abundance-based dissimilarity metrics</li> <li>Differential expression analysis with DESeq2</li> <li>Introduction to RNA-Seq with Galaxy</li> <li>Evaluation of 16S rRNA Databases for Taxonomic Assignments Using a Mock Community</li> <li>Wild Mouse Gut Microbiota Promotes Host Fitness and Improves Disease Resistance</li> <li>Normalization and microbial differential abundance strategies depend upon data characteristics</li> <li>Waste Not, Want Not: Why Rarefying Microbiome Data Is Inadmissible</li> <li>A Primer on Metagenomics</li> <li>Clustal W and Clustal X version 2.0</li> <li>The neighbor-joining method: a new method for reconstructing phylogenetic trees.</li> <li>Large-scale contamination of microbial isolate genomes by Illumina PhiX control</li> <li>Dadasnake, a Snakemake implementation of DADA2 to process amplicon sequencing data for microbial ecology</li> </ol>"},{"location":"intro16S/test/","title":"Test","text":"<p>Some text</p>"}]}